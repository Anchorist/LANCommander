@inherits OwningComponentBase
@using System.Net;
@using System.Diagnostics;
@using Hangfire;
@using LANCommander.Server.Jobs.Background;
@using Microsoft.EntityFrameworkCore;
@inject HttpClient HttpClient
@inject NavigationManager Navigator
@inject IMessageService MessageService
@inject IJSRuntime JS
@inject ILogger<ArchiveUploader> Logger

@{
    RenderFragment Footer =
    @<Template>
        <FilePickerButton EntrySelectable="@(entry => !String.IsNullOrWhiteSpace(entry.Name) && entry.Name.ToLower().EndsWith(".zip"))"
            OnSelected="OnLocalFileSelected"
            Root="@RootPath"
            Disabled="@(Status != "" || String.IsNullOrWhiteSpace(Archive.Version))">
            Use Local File
        </FilePickerButton>
        <Button OnClick="Start" Disabled="@(File == null || Status != "" || String.IsNullOrWhiteSpace(Archive.Version))" Type="@ButtonType.Primary">Upload</Button>
        <Button OnClick="Cancel">Cancel</Button>
    </Template>;
}

<Modal Visible="@Visible" Title="Upload Archive" OnOk="Start" OnCancel="Cancel" Footer="@Footer" Closable="@(!Uploading)" MaskClosable="@(!Uploading)">
    <Form Model="@Archive" Layout="@FormLayout.Vertical">
        <FormItem Label="Version">
            <Input @bind-Value="@context.Version" /> 
        </FormItem>

        <FormItem Label="Changelog">
            <TextArea @bind-Value="@context.Changelog" MaxLength=500 ShowCount />
        </FormItem>

        <FormItem Label="Path">
            <Select TItem="StorageLocation"
                TItemValue="Guid"
                DataSource="@StorageLocations.OrderBy(l => l.Default)"
                @bind-Value="@context.StorageLocationId"
                LabelName="Path"
                ValueName="Id"
                Placeholder="Select a Path"
                DefaultActiveFirstOption="true"
                EnableSearch />
        </FormItem>

        <FormItem>
            <ChunkUploader @ref="ChunkUploader" Accept=".zip" @bind-File="File" @bind-Status="Status" @bind-Version="context.Version" @bind-Changelog="context.Changelog" @bind-StorageLocationId="context.StorageLocationId" OnUploadCompleted="OnUploadCompleted" OnUploadError="OnUploadError">
                <Text>
                    <p>Drag and Drop</p>
                    <p>or</p>
                    <p>
                        <Button Type="@ButtonType.Primary" Style="margin-top: 8px;">Browse</Button>
                    </p>
                </Text>
                <Hint>Only ZIP files are supported as game archives</Hint>
            </ChunkUploader>
        </FormItem>
    </Form>
</Modal>

@code {
    [Parameter] public Guid GameId { get; set; }
    [Parameter] public Guid RedistributableId { get; set; }
    [Parameter] public EventCallback<Guid> OnArchiveUploaded { get; set; }

    ArchiveService ArchiveService;
    StorageLocationService StorageLocationService;

    Archive Archive;

    string RootPath = Path.GetPathRoot(Directory.GetCurrentDirectory());

    IBrowserFile File;
    ChunkUploader ChunkUploader;

    IEnumerable<StorageLocation> StorageLocations;

    bool IsValid = false;
    bool Visible = false;
    bool Uploading = false;

    string Filename;

    string Status;

    protected override void OnInitialized()
    {
        ArchiveService = ScopedServices.GetService<ArchiveService>()!;
        StorageLocationService = ScopedServices.GetService<StorageLocationService>()!;
    }

    private async Task Start()
    {
        Uploading = true;
        await ChunkUploader.Start();
    }

    private async Task Clear()
    {
        await ChunkUploader.Clear();
    }

    private async Task Cancel()
    {
        await ChunkUploader.Clear();
        Visible = false;
    }

    public async Task Open(Guid? archiveId = null)
    {
        StorageLocations = await StorageLocationService.GetAsync(l => l.Type == SDK.Enums.StorageLocationType.Archive);

        if (archiveId.HasValue && archiveId != Guid.Empty)
        {
            Archive = await ArchiveService.GetAsync(archiveId.Value);
        }
        else
        {
            Archive = new Archive();

            if (GameId != Guid.Empty)
                Archive.GameId = GameId;
            else if (RedistributableId != Guid.Empty)
                Archive.RedistributableId = RedistributableId;
        }

        Visible = true;

        await InvokeAsync(StateHasChanged);
    }

    public async Task OnUploadCompleted(string data)
    {
        Uploading = false;

        if (Guid.TryParse(data, out var objectKey))
        {
            var uploadedArchive = await ArchiveService.FirstOrDefaultAsync(a => a.ObjectKey == objectKey.ToString());

            uploadedArchive.GameId = Archive.GameId;
            uploadedArchive.RedistributableId = Archive.RedistributableId;
            uploadedArchive.Version = Archive.Version;
            uploadedArchive.Changelog = Archive.Changelog;
            uploadedArchive.CompressedSize = ArchiveService.GetCompressedSize(uploadedArchive);
            uploadedArchive.UncompressedSize = ArchiveService.GetUncompressedSize(uploadedArchive);

            await ArchiveService.UpdateAsync(uploadedArchive);

            Visible = false;

            await InvokeAsync(StateHasChanged);

            Archive? lastArchive = null;

            var settings = SettingService.GetSettings();

            if (settings.Archives.EnablePatching)
            {
                if (Archive.GameId != Guid.Empty)
                    lastArchive = await ArchiveService.FirstOrDefaultAsync(a => a.Id != Archive.Id && a.GameId == Archive.GameId, a => a.CreatedOn);
                else if (Archive.RedistributableId != Guid.Empty)
                    lastArchive = await ArchiveService.FirstOrDefaultAsync(a => a.Id != Archive.Id && a.RedistributableId == Archive.RedistributableId, a => a.CreatedOn);

                if (lastArchive != null && settings.Archives.EnablePatching)
                    BackgroundJob.Enqueue<PatchArchiveBackgroundJob>(x => x.Execute(lastArchive.Id, Archive.Id));
            }

            if (OnArchiveUploaded.HasDelegate)
                await OnArchiveUploaded.InvokeAsync(Archive.Id);

            MessageService.Success("Archive uploaded!");
        }
        else
        {
            Visible = false;

            await InvokeAsync(StateHasChanged);

            MessageService.Error("Archive failed to upload!");
            Logger.LogError("Archive failed to upload!");
        }

        await ChunkUploader.Clear();
    }

    public async Task OnUploadError(string message)
    {
        Uploading = false;
        Visible = false;

        await InvokeAsync(StateHasChanged);

        MessageService.Error("Archive failed to upload!");
        Logger.LogError($"Archive failed to upload: {message}");
    }

    public async Task OnLocalFileSelected(string path)
    {
        try
        {
            var objectKey = await ArchiveService.CopyFromLocalFileAsync(path);

            await OnUploadCompleted(objectKey.ToString());
        }
        catch (Exception ex)
        {
            MessageService.Error("An unknown error occurred while trying to use a local file");
            Logger.LogError(ex, "An unknown error occurred while trying to use a local file");
        }
    }
}
