@using AntDesign.TableModels;
@inject ArchiveService ArchiveService
@inject IMessageService MessageService

<div class="file-manager">
    <GridRow Class="file-manager-nav">
        <Space>
            <SpaceItem>
                <Tooltip Title="Back" MouseEnterDelay="2">
                    <Button Type="@ButtonType.Text" Icon="@IconType.Outline.ArrowLeft" OnClick="NavigateBack" />
                </Tooltip>
            </SpaceItem>
            <SpaceItem>
                <Tooltip Title="Forward" MouseEnterDelay="2">
                    <Button Type="@ButtonType.Text" Icon="@IconType.Outline.ArrowRight" OnClick="NavigateForward" />
                </Tooltip>
            </SpaceItem>
            <SpaceItem>
                <Tooltip Title="Up a Level" MouseEnterDelay="2">
                    <Button Type="@ButtonType.Text" Icon="@IconType.Outline.ArrowUp" OnClick="NavigateUp" Disabled="@(Path.Parent == null)" />
                </Tooltip>
            </SpaceItem>
            <SpaceItem>
                <Tooltip Title="Refresh" MouseEnterDelay="2">
                    <Button Type="@ButtonType.Text" Icon="@IconType.Outline.Reload" OnClick="Refresh" />
                </Tooltip>
            </SpaceItem>
            <SpaceItem Class="file-manager-nav-breadcrumbs">
                <Breadcrumb>
                    @foreach (var breadcrumb in Breadcrumbs)
                    {
                        <BreadcrumbItem OnClick="() => ChangeDirectory(breadcrumb, false)">@breadcrumb.Name</BreadcrumbItem>
                    }
                </Breadcrumb>
            </SpaceItem>
            <SpaceItem>
                <Tooltip Title="New Folder" MouseEnterDelay="2">
                    <Button Type="@ButtonType.Text" Icon="@IconType.Outline.FolderAdd" OnClick="() => NewFolderModal.Open()" />
                </Tooltip>
            </SpaceItem>
            <SpaceItem>
                <Tooltip Title="Upload File" MouseEnterDelay="2">
                    <Button Type="@ButtonType.Text" Icon="@IconType.Outline.Upload" OnClick="() => UploadModal.Open()" />
                </Tooltip>
            </SpaceItem>
            <SpaceItem>
                <Tooltip Title="Delete" MouseEnterDelay="2">
                    <Button Type="@ButtonType.Text" Icon="@IconType.Outline.Delete" OnClick="Delete" Disabled="@(Selected.Count() == 0)" />
                </Tooltip>
            </SpaceItem>
        </Space>
    </GridRow>

    <GridRow>
        <GridCol Span="6" Class="file-manager-tree">
            <Tree TItem="FileManagerDirectory"
                  DataSource="Directories"
                  SwitcherIcon="@IconType.Outline.Down"
                  TitleExpression="x => x.DataItem.Name"
                  ChildrenExpression="x => x.DataItem.Children"
                  IsLeafExpression="x => !x.DataItem.HasChildren"
                  IconExpression="x => x.Expanded ? IconType.Outline.FolderOpen : IconType.Outline.Folder"
                  DefaultExpandParent="true"
                  OnClick="(args) => ChangeDirectory(args.Node.DataItem, false)"
                  OnNodeLoadDelayAsync="ExpandTree">
                <SwitcherIconTemplate>
                    <Icon Type="@IconType.Outline.Down" />
                </SwitcherIconTemplate>
                <TitleIconTemplate>
                    @if (context.Expanded)
                    {
                        <Icon Type="@IconType.Outline.FolderOpen" />
                    }
                    else
                    {
                        <Icon Type="@IconType.Outline.Folder" />
                    }
                </TitleIconTemplate>
            </Tree>
        </GridCol>

        <GridCol Span="18" Class="file-manager-list">
            <Table TItem="IFileManagerEntry"
                   DataSource="Entries"
                   HidePagination="true"
                   Loading="Entries == null"
                   OnRow="OnRow"
                   @bind-SelectedRows="Selected"
                   Size="@TableSize.Small">
                <Selection Key="@context.Path" Type="@(SelectMultiple ? "checkbox" : "radio")" />
                <Column TData="string" Width="32">
                    @if (context is FileManagerFile)
                    {
                        <Icon Type="@(((FileManagerFile)context).GetIcon())" Theme="outline" />
                    }
                    else if (context is FileManagerDirectory)
                    {
                        <Icon Type="@IconType.Outline.Folder" />
                    }
                </Column>
                <PropertyColumn Property="e => e.Path" Sortable Title="Name">
                    @GetEntryName(context)
                </PropertyColumn>
                <PropertyColumn Property="e => e.Size" Sortable Title="Size">
                    @ByteSizeLib.ByteSize.FromBytes(context.Size)
                </PropertyColumn>
                <PropertyColumn Property="e => e.ModifiedOn" Format="MM/dd/yyyy hh:mm tt" Sortable Title="Modified" />
             </Table>
         </GridCol>
     </GridRow>
</div>

<NewFolderModal @ref="NewFolderModal" OnFolderNameEntered="AddFolder" />
<UploadModal @ref="UploadModal" Path="@Path.Path" OnUploadCompleted="() => Refresh()" />

 @code {
    [Parameter] public Guid ArchiveId { get; set; }
    [Parameter] public string WorkingDirectory { get; set; }
    [Parameter] public bool SelectMultiple { get; set; } = true;
    [Parameter] public IEnumerable<IFileManagerEntry> Selected { get; set; } = new List<IFileManagerEntry>();
    [Parameter] public EventCallback<IEnumerable<IFileManagerEntry>> SelectedChanged { get; set; }

    FileManagerDirectory Path { get; set; }

    List<FileManagerDirectory> Past { get; set; } = new List<FileManagerDirectory>();
    List<FileManagerDirectory> Future { get; set; } = new List<FileManagerDirectory>();
    List<FileManagerDirectory> Breadcrumbs = new List<FileManagerDirectory>();

    List<IFileManagerEntry> Entries { get; set; } = new List<IFileManagerEntry>();
    HashSet<FileManagerDirectory> Directories { get; set; } = new HashSet<FileManagerDirectory>();

    NewFolderModal NewFolderModal;
    UploadModal UploadModal;

    Dictionary<string, object> OnRow(RowData<IFileManagerEntry> row) => new()
    {
        ["data-path"] = row.Data.Path,
        ["ondblclick"] = ((System.Action)delegate
        {
            if (row.Data is FileManagerDirectory)
                ChangeDirectory((FileManagerDirectory)row.Data, true);
        })
    };

    protected override async Task OnParametersSetAsync()
    {
        if (!String.IsNullOrWhiteSpace(WorkingDirectory))
        {
            Directories = GetDirectories(WorkingDirectory);
        }
        else if (ArchiveId != Guid.Empty)
        {
            Directories = await GetArchiveDirectories(ArchiveId);
        }
    }

    HashSet<FileManagerDirectory> GetDirectories(string path)
    {
        var paths = Directory.EnumerateDirectories(path, "*", new EnumerationOptions
        {
            IgnoreInaccessible = true,
            RecurseSubdirectories = true,
            MaxRecursionDepth = 1
        });

        var root = new FileManagerDirectory
        {
            Name = path,
            Path = path,
            IsExpanded = true
        };

        root.PopulateChildren(paths);

        ChangeDirectory(root, true);

        return new HashSet<FileManagerDirectory>
        {
            root
        };
    }

    async Task<HashSet<FileManagerDirectory>> GetArchiveDirectories(Guid archiveId)
    {
        var entries = await ArchiveService.GetContents(archiveId);
        var directories = new HashSet<FileManagerDirectory>();

        var root = new FileManagerDirectory
        {
            Name = "/",
            Path = "",
            IsExpanded = true
        };

        root.PopulateChildren(entries);

        ChangeDirectory(root, true);

        return new HashSet<FileManagerDirectory>
        {
            root
        };
    }

    string GetEntryName(IFileManagerEntry entry)
    {
        if (String.IsNullOrWhiteSpace(entry.Name) && entry.Size == 0)
        {
            return entry.Path.TrimEnd('/').Split('/').Last();
        }
        else
            return entry.Name;
    }

    void ChangeDirectory(FileManagerDirectory directory, bool clearFuture)
    {
        Past.Add(Path);

        Path = directory;

        UpdateEntries();
        UpdateBreadcrumbs();

        if (clearFuture)
            Future.Clear();

        StateHasChanged();
    }

    async Task ExpandTree(TreeEventArgs<FileManagerDirectory> args)
    {
        var directory = (FileManagerDirectory)args.Node.DataItem;

        foreach (var child in directory.Children)
        {
            var paths = Directory.EnumerateDirectories(child.Path, "*", new EnumerationOptions
            {
                IgnoreInaccessible = true,
                RecurseSubdirectories = true,
                MaxRecursionDepth = 1
            });

            child.PopulateChildren(paths);
        }
    }

    void UpdateEntries()
    {
        Entries.Clear();
        var entries = Directory.EnumerateFileSystemEntries(Path.Path);
        var separator = System.IO.Path.DirectorySeparatorChar;

        foreach (var entry in Directory.EnumerateFileSystemEntries(Path.Path))
        {
            if (Directory.Exists(entry))
            {
                var info = new DirectoryInfo(entry);

                Entries.Add(new FileManagerDirectory
                {
                    Path = entry,
                    Name = entry.Substring(Path.Path.Length).TrimStart(separator),
                    ModifiedOn = info.LastWriteTime,
                    CreatedOn = info.CreationTime,
                });
            }
            else
            {
                var info = new FileInfo(entry);

                Entries.Add(new FileManagerFile
                {
                    Path = entry,
                    Name = System.IO.Path.GetFileName(entry),
                    ModifiedOn = info.LastWriteTime,
                    CreatedOn = info.CreationTime,
                    Size = info.Length
                });
            }
        }
    }

    void UpdateBreadcrumbs()
    {
        Breadcrumbs.Clear();

        var currentPath = Path;

        while (currentPath != null)
        {
            Breadcrumbs.Add(currentPath);

            currentPath = currentPath.Parent;
        }

        Breadcrumbs.Reverse();
    }

    void NavigateBack()
    {
        if (Past.Count > 0)
        {
            Future.Add(Path);
            Path = Past.Last();
            Past = Past.Take(Past.Count - 1).ToList();
        }
    }

    void NavigateForward()
    {
        if (Future.Count > 0)
        {
            Past.Add(Path);
            Path = Future.First();
            Future = Future.Skip(1).ToList();
        }
    }

    void NavigateUp()
    {
        if (Path.Parent != null)
            ChangeDirectory(Path.Parent, true);
    }

    void Refresh()
    {
        ChangeDirectory(Path, false);
    }

    void AddFolder(string name)
    {
        try
        {
            Directory.CreateDirectory(System.IO.Path.Combine(Path.Path, name));

            Refresh();

            MessageService.Success("Folder created!");
        }
        catch
        {
            MessageService.Error("Error creating folder!");
        }
    }

    void Delete()
    {
        try
        {
            foreach (var entry in Selected)
            {
                if (entry is FileManagerDirectory)
                    Directory.Delete(entry.Path);
                else if (entry is FileManagerFile)
                    File.Delete(entry.Path);
            }

            Selected = new List<IFileManagerEntry>();
            MessageService.Success("Deleted!");
        }
        catch
        {
            MessageService.Error("Error deleting!");
        }

        Refresh();
    }
}
