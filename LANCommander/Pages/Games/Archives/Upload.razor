@page "/Games/{id:guid}/Archives/Upload"
@using System.Net;
@using System.Diagnostics;
@inject HttpClient HttpClient
@inject NavigationManager Navigator

<MudFileUpload T="IBrowserFile" OnFilesChanged="FileSelected">
    <ButtonTemplate>
        <MudButton HtmlTag="label"
                   Variant="Variant.Filled"
                   Color="Color.Primary"
                   StartIcon="@Icons.Material.Filled.CloudUpload"
                   for="@context">
            Upload Archive
        </MudButton>
    </ButtonTemplate>
</MudFileUpload>

<MudButton OnClick="UploadArchive">Upload</MudButton>

<MudProgressLinear Color="Color.Primary" Striped="Uploading" Size="Size.Large" Value="Progress" />

<MudText>@ByteSizeLib.ByteSize.FromBytes(Speed)/s</MudText>

@code {
    [Parameter] public Guid Id { get; set; }

    IBrowserFile File { get; set; }

    const int ChunkSize = 1024 * 1024 * 10;

    int Progress = 0;
    bool Uploading = false;
    double Speed = 0;

    protected override async Task OnInitializedAsync()
    {
        HttpClient.BaseAddress = new Uri(Navigator.BaseUri);
    }

    private void FileSelected(InputFileChangeEventArgs args)
    {
        File = args.File;
    }

    private async Task UploadArchive()
    {
        var archiveId = Guid.NewGuid();

        long uploadedBytes = 0;
        long totalBytes = File.Size;

        using (var stream = File.OpenReadStream(long.MaxValue))
        {
            Uploading = true;

            var watch = new Stopwatch();

            watch.Start();

            while (Uploading)
            {
                byte[] chunk;

                if (totalBytes - uploadedBytes < ChunkSize)
                    chunk = new byte[totalBytes - uploadedBytes];
                else
                    chunk = new byte[ChunkSize];

                int bytesRead = 0;

                // This feels hacky, why do we need to do this?
                // Only 32256 bytes of the file get read unless we
                // loop through like this. Probably kills performance.
                while (bytesRead < chunk.Length) {
                    bytesRead += await stream.ReadAsync(chunk, bytesRead, chunk.Length - bytesRead);
                }

                using (FileStream fs = new FileStream(Path.Combine("Upload", archiveId.ToString()), FileMode.Append))
                {
                    await fs.WriteAsync(chunk);
                }

                uploadedBytes += chunk.Length;

                Progress = (int)(uploadedBytes * 100 / totalBytes);

                if (Progress >= 100)
                    Uploading = false;

                Speed = chunk.Length * (1 / watch.Elapsed.TotalSeconds);

                watch.Restart();

                await InvokeAsync(StateHasChanged);
            }
        }
    }
}
