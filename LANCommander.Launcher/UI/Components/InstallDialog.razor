@using System.Diagnostics
@using LANCommander.Launcher.Data.Models
@using LANCommander.Launcher.Models
@using LANCommander.Launcher.Services.Extensions
@inherits FeedbackComponent<LibraryItem, string>
@inject LibraryService LibraryService
@inject SDK.Client Client

<Row Gutter="16">
    <Col Span="12">
        <Statistic Title="Download Size" Value="@ByteSizeLib.ByteSize.FromBytes(GetDownloadSize()).ToString()" />
    </Col>
    <Col Span="12">
        <Statistic Title="Space Required" Value="@ByteSizeLib.ByteSize.FromBytes(GetSpaceRequired()).ToString()" />
    </Col>
</Row>

@if (Addons.Any())
{
    <Collapse Class="install-dialog-addons-selector">
        <Panel Header="Addons">
            <ExtraTemplate>
                @SelectedAddonIds.Length / @Addons.Count Selected
            </ExtraTemplate>
            <ChildContent>
                <CheckboxGroup Style="width: 100%" TValue="string" ValueChanged="@OnAddonsSelectedChange">
                    @foreach (var addon in Addons)
                    {
                        <Checkbox Label="@addon.Id.ToString()">
                            <Text>@addon.Title</Text>
                            <Text Type="@TextElementType.Secondary">@addon.Description</Text>
                        </Checkbox>
                    }
                </CheckboxGroup>
            </ChildContent>
        </Panel>
    </Collapse>
}

<RadioGroup @bind-Value="SelectedDirectory" ButtonStyle="RadioButtonStyle.Solid" Size="large" Class="install-dialog-directory-selector radio-group-vertical radio-group-block">
    @foreach (var directory in Settings.Games.InstallDirectories)
    {
        <Radio RadioButton Value="@directory">
            <GridRow>
                <GridCol Flex="@("auto")">
                    @directory
                </GridCol>
                <GridCol>
                    @ByteSizeLib.ByteSize.FromBytes(GetFreeSpace(directory))
                </GridCol>
            </GridRow>
        </Radio>
    }
</RadioGroup>

@code {
    Settings Settings = SettingService.GetSettings();

    string SelectedDirectory = "";
    List<SDK.Models.Game> Addons = new();
    SDK.Models.Game RemoteGame;

    Guid[] SelectedAddonIds = new Guid[] { };

    protected override async Task OnInitializedAsync()
    {
        SelectedDirectory = Settings.Games.InstallDirectories.First();

        var game = Options.DataItem as Game;

        RemoteGame = await Client.Games.GetAsync(Options.Key);

        Addons = RemoteGame.DependentGames.Where(g => g.Type.IsIn(SDK.Enums.GameType.Expansion, SDK.Enums.GameType.Mod)).OrderByTitle(g => g.Title ?? g.SortTitle).ToList();
    }

    public override async Task OnFeedbackOkAsync(ModalClosingEventArgs args)
    {
        LibraryService.Install(Options, SelectedDirectory, SelectedAddonIds);
    }

    void OnAddonsSelectedChange(string[] selectedIds)
    {
        try
        {
            SelectedAddonIds = selectedIds.Select(id => Guid.Parse(id)).ToArray();
        }
        catch (Exception ex)
        {
            SelectedAddonIds = new Guid[] { };
        }
    }

    long GetDownloadSize()
    {
        long size = 0;

        if (RemoteGame != null && RemoteGame.Archives.Any())
        {
            size += RemoteGame.Archives.OrderByDescending(a => a.CreatedOn).First().CompressedSize;

            foreach (var dependentGame in RemoteGame.DependentGames.Where(dg => SelectedAddonIds.Contains(dg.Id)))
            {
                size += dependentGame.Archives.OrderByDescending(a => a.CreatedOn).First().CompressedSize;
            }
        }

        return size;
    }

    long GetSpaceRequired()
    {
        long size = 0;

        if (RemoteGame != null && RemoteGame.Archives.Any())
        {
            size += RemoteGame.Archives.OrderByDescending(a => a.CreatedOn).First().UncompressedSize;

            foreach (var dependentGame in RemoteGame.DependentGames)
            {
                size += dependentGame.Archives.OrderByDescending(a => a.CreatedOn).First().UncompressedSize;
            }
        }

        return size;
    }

    long GetFreeSpace(string path)
    {
        var root = Path.GetPathRoot(path);
        var drive = new DriveInfo(path);

        return drive.AvailableFreeSpace;
    }
}